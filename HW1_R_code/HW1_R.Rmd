---
title: "HW1 Econometrics 3"
author: "Matthew Aaron Looney"
date: "9/11/2017"
output: pdf_document
---

```{r straight OLS, echo=FALSE, message=FALSE, results='asis', cache=F}

cat("\014")
rm(list=ls())
set.seed(12345)

 library(readr)
library(gvlma)
library(lmtest)
library(stargazer)

data <- read_csv("~/Google Drive/digitalLibrary/*Econometrics3/Econometrics3/HW1_MatLab_Code/data.csv", col_names = FALSE)

n=20 # sample size
k=3 # number of paramaters in model
reps <- 1e2 # number of ols iterations
i <- 1 # counter
temp <- matrix(nrow = reps, ncol = 14) # matrix to stuff results into dim= "reps" X k+3
x1 <- data$X2
x2 <- data$X3

for(i in 1:reps){
  
#e <- rnorm(n=n, mean=0, sd=5) # n-random normal draws for error term
#x1 <- rnorm(n=n, mean=100, sd=7) # n-random normal draws for x1 data
#x2 <- rnorm(n=n, mean=1000, sd=10) # n-random normal draws for x2 data
e= sqrt(exp(-2+ 0.25* x1)) *rnorm(n)

y <- 10+ 1* x1+ 1* x2 +e # construct model

X <- matrix(c(rep(1, n), x1, x2), nrow=n, ncol=k) # gather X-data into single matrix

b_ols <- solve(crossprod(X, X)) %*% crossprod(X, y) # faster to use matrix algebra over lm function

ehat <- y-(X %*% b_ols)
sigma2 <- (t(ehat) %*% ehat) / (n-k)
sigma2 <- as.numeric(sigma2)
covb <- diag(sigma2 * solve(crossprod(X, X)))

bp_ols <- lm(y~x1+x2)
bp_test <- bptest(bp_ols, studentize = F)
gvHet_test <- gvlma(bp_ols)

temp[i, 1] <- b_ols[1]
temp[i, 2] <- b_ols[2]
temp[i, 3] <- b_ols[3]
temp[i, 4] <- covb[1]
temp[i, 5] <- covb[2]
temp[i, 6] <- covb[3]
temp[i, 7] <- sqrt(covb[1])
temp[i, 8] <- sqrt(covb[2])
temp[i, 9] <- sqrt(covb[3])
temp[i, 10] <- mean(b_ols[1]/sqrt(covb[1]))
temp[i, 11] <- mean(b_ols[2]/sqrt(covb[2]))
temp[i, 12] <- mean(b_ols[3]/sqrt(covb[3]))
temp[i, 13] <- unlist(bp_test[1])
temp[i, 14] <- gvHet_test$GlobalTest$DirectionalStat4$Value

i <- i+1
}
  
dimnames(temp) <- list(c(), c("beta_0_ols", "beta_1_ols", "beta_2_ols", "var_b0_ols", "var_b1_ols", "var_b2_ols", "se_b0_ols", "se_b1_ols", "se_b2_ols", "t_val_b0_ols", "t_val_b1_ols", "t_val_b2_ols", "BP_testStat_ols", "GV_HET_Test_ols"))
  
# ols_params_mu <- matrix(nrow=3, ncol=3)
# 
# ols_params_mu[1,1] <- mean(temp[,1])
# ols_params_mu[2,1] <- mean(temp[,2])
# ols_params_mu[3,1] <- mean(temp[,3])
# 
# ols_params_mu[1,2] <- sqrt(mean(temp[, 4]))
# ols_params_mu[2,2] <- sqrt(mean(temp[, 5]))
# ols_params_mu[3,2] <- sqrt(mean(temp[, 6]))
# 
# ols_params_mu[1,3] <- mean(temp[,1])/ sqrt(mean(temp[, 4]))
# ols_params_mu[2,3] <- mean(temp[,2])/ sqrt(mean(temp[, 5]))
# ols_params_mu[3,3] <- mean(temp[,3])/ sqrt(mean(temp[, 6]))
# 
# dimnames(ols_params_mu) <- list(c(), c("betas_ols", "se_ols", "t_values_ols"))
# ols_params_mu

#ehat <- y-(X %*% b_ols)
# sigma2 <- (t(ehat) %*% ehat) / (n-k)
# sigma2 <- as.numeric(sigma2)
# covb <- sigma2 * solve(crossprod(X, X))
# se_b <- sqrt(diag(covb))
# t_val <- mu_betas/se_b
# dimnames(t_val) <- list(c(), c("t_values_ols"))
# t_val

```
  
# OLS  
  
```{r, echo=FALSE, message=FALSE, results='asis', fig.height=3, results='asis'}

stargazer(temp, header=F, type="latex", summary = T, font.size = "small", notes= c("good 1 = meats", "good 2 = dairy", "good 3 = beans"), notes.align= "l", flip = F, float = T, float.env = "table", title="Summary Statistics", median = F)

 # par(mfrow=c(1,3))
 # hist(temp[,1])
 # hist(temp[,2])
 # hist(temp[,3])

```
  
```{r OLS with GLS, echo=FALSE, message=FALSE, results='asis', fig.height=3}

cat("\014")
rm(list=ls())
set.seed(12345)

library(readr)
library(car)

data <- read_csv("~/Google Drive/digitalLibrary/*Econometrics3/Econometrics3/HW1_MatLab_Code/data.csv", col_names = FALSE)
x1 <- data$X2
x2 <- data$X3

n=20 # sample size
k=3 # number of paramaters in model
reps <- 1e2 # number of ols iterations
i <- 1 # counter
temp <- matrix(nrow = reps, ncol = 30) # matrix to stuff results into dim= "reps" X k+3

for(i in 1:reps){
  
#e <- rnorm(n=n, mean=0, sd=5) # n-random normal draws for error term
#x1 <- rnorm(n=n, mean=100, sd=7) # n-random normal draws for x1 data
#x2 <- rnorm(n=n, mean=1000, sd=10) # n-random normal draws for x2 data
e= sqrt(exp(-2+ 0.25* x1)) *rnorm(n)

y <- matrix(10+ 1* x1+ 1* x2 +e) # construct model

X <- matrix(c(rep(1, n), x1, x2), nrow=n, ncol=k) # gather X-data into single matrix

b_ols <- solve( crossprod(X, X) ) %*% crossprod(X, y) # faster to use matrix algebra over lm function

ehat <- y-(X %*% b_ols)
sigma2 <- (t(ehat) %*% ehat) / (n-k)
sigma2 <- as.numeric(sigma2)
covb <- diag(sigma2 * solve(crossprod(X, X)))

### GLS section ###

ehat2 <- ehat^2
w_gls <- solve( crossprod(X, X) ) %*% crossprod(X, log(ehat2))
w_gls_hat <- exp(w_gls[1]+ w_gls[2]* x1+ w_gls[3]* x2)
w_gls_hat_sq <- diag(w_gls_hat)
w_gls_hat_inv <- solve(w_gls_hat_sq)

b_ols_fgls <- solve( t(X) %*% w_gls_hat_inv %*% X ) %*% ( t(X) %*% w_gls_hat_inv %*% y )
#te <- lm(y~ x1+x2, weights=w_gls_hat^-1)

#vcov_ols_fgls <- sigma2*solve(t(X)%*% w_gls_hat_inv%*% X)
# pg 270 greene, 7th Ed.
vcov_ols_fgls <- sigma2 * (solve( crossprod(X, X) ) %*% ( t(X) %*% w_gls_hat_inv %*% X ) %*% solve(crossprod(X, X)) )

vcov_ols_fgls_diag <- diag(vcov_ols_fgls)

te1 <- lm(y~ x1+x2)
vcovHCCM0 <- diag(hccm(te1, type="hc0"))
vcovHCCM3 <- diag(hccm(te1, type="hc3"))

temp[i, 1] <- b_ols[1]
temp[i, 2] <- b_ols[2]
temp[i, 3] <- b_ols[3]
temp[i, 4] <- covb[1]
temp[i, 5] <- covb[2]
temp[i, 6] <- covb[3]
temp[i, 7] <- sqrt(covb[1])
temp[i, 8] <- sqrt(covb[2])
temp[i, 9] <- sqrt(covb[3])
temp[i, 10] <- mean(b_ols[1]/sqrt(covb[1]))
temp[i, 11] <- mean(b_ols[2]/sqrt(covb[2]))
temp[i, 12] <- mean(b_ols[3]/sqrt(covb[3]))
temp[i, 13] <- b_ols_fgls[1]
temp[i, 14] <- b_ols_fgls[2]
temp[i, 15] <- b_ols_fgls[3]
temp[i, 16] <- vcov_ols_fgls_diag[1]
temp[i, 17] <- vcov_ols_fgls_diag[2]
temp[i, 18] <- vcov_ols_fgls_diag[3]
temp[i, 19] <- sqrt(vcov_ols_fgls_diag[1])
temp[i, 20] <- sqrt(vcov_ols_fgls_diag[2])
temp[i, 21] <- sqrt(vcov_ols_fgls_diag[3])
temp[i, 22] <- (b_ols_fgls[1])/sqrt(vcov_ols_fgls_diag[1])
temp[i, 23] <- (b_ols_fgls[2])/sqrt(vcov_ols_fgls_diag[2])
temp[i, 24] <- (b_ols_fgls[3])/sqrt(vcov_ols_fgls_diag[3])
temp[i, 25] <- vcovHCCM0[1]
temp[i, 26] <- vcovHCCM0[2]
temp[i, 27] <- vcovHCCM0[3]
temp[i, 28] <- vcovHCCM3[1]
temp[i, 29] <- vcovHCCM3[2]
temp[i, 30] <- vcovHCCM3[3]

i <- i+1
}
  
dimnames(temp) <- list(c(), c("beta_0_ols", "beta_1_ols", "beta_2_ols", "var_b0_ols", "var_b1_ols", "var_b2_ols", "se_b0_ols", "se_b1_ols", "se_b2_ols", "t_val_b0_ols", "t_val_b1_ols", "t_val_b2_ols", "beta_0_fgls", "beta_1_fgls", "beta_2_fgls", "var_b0_fgls", "var_b1_fgls", "var_b2_fgls", "se_b0_fgls", "se_b1_fgls", "se_b2_fgls", "t_val_b0_fgls", "t_val_b1_fgls", "t_val_b2_fgls", "var_b0_HCCM_0", "var_b1_HCCM_0", "var_b2_HCCM_0", "var_b0_HCCM_3", "var_b1_HCCM_3", "var_b2_HCCM_3"))
  
# ols_params_mu <- matrix(nrow=3, ncol=2)
# ols_params_mu[1,1] <- mean(temp[,1])
# ols_params_mu[2,1] <- mean(temp[,2])
# ols_params_mu[3,1] <- mean(temp[,3])
# ols_params_mu[1,2] <- mean(temp[,1])/ sqrt(mean(temp[, 4]))
# ols_params_mu[2,2] <- mean(temp[,2])/ sqrt(mean(temp[, 5]))
# ols_params_mu[3,2] <- mean(temp[,3])/ sqrt(mean(temp[, 6]))
# 
# dimnames(ols_params_mu) <- list(c(), c("betas_ols", "t_values_ols"))
# ols_params_mu

# ehat <- y-(X %*% b_ols)
# sigma2 <- (t(ehat) %*% ehat) / (n-k)
# sigma2 <- as.numeric(sigma2)
# covb <- sigma2 * solve(crossprod(X, X))
# se_b <- sqrt(diag(covb))
# t_val <- mu_betas/se_b
# dimnames(t_val) <- list(c(), c("t_values_ols"))
# t_val

```
  
\newpage  
  
# FGLS  
  
Estimate the model using FGLS techniques  Assume multiplicative hetero...  
  

```{r, echo=FALSE, message=FALSE, results='asis', fig.height=3, results='asis'}

stargazer(temp, header=F, type="latex", summary = T, font.size = "small", notes= c("good 1 = meats", "good 2 = dairy", "good 3 = beans"), notes.align= "l", flip = F, float = T, float.env = "table", title="Summary Statistics", median = F)

 # par(mfrow=c(1,3))
 # hist(temp[,1])
 # hist(temp[,2])
 # hist(temp[,3])

```
  
```{r, echo=FALSE, message=FALSE, results='asis', fig.height=3}

###################
### MLE Section ###
###################

### housekeeping ###

cat("\014")
rm(list=ls())
set.seed(12345)

 library(readr)

data <- read_csv("~/Google Drive/digitalLibrary/*Econometrics3/Econometrics3/HW1_MatLab_Code/data.csv", col_names = FALSE)

n=20 # sample size
k=3 # number of paramaters in model
reps <- 1e2 # number of ols iterations
i <- 1 # counter
temp <- matrix(nrow = reps, ncol = k) # matrix to stuff results into dim= "reps" X 3
x1 <- data$X2
x2 <- data$X3

### MLE functions ###

hw1.loglike <- function(params, y, x1, x2)
{
  beta1 <- params[1]
  beta2 <- params[2]
  beta3 <- params[3]
  beta4 <- params[4]
  beta5 <- params[5]
  
  n <- length(x1)
    
    lnL= -0.5* n* log(2* pi)- 0.5* sum(beta4+ beta5* x1)- 0.5* sum( ( (y- (beta1+ beta2* x1+ beta3* x2))^2 )/ ( exp(beta4+ beta5* x1) ) ) 
  
  return(lnL)
}

hw1.mle <- function( par0, y, x1, x2)
{
  
   temp.mle <- optim(par0, hw1.loglike, y=y, x1=x1, x2=x2, method="Nelder-Mead", 
                     control=list(fnscale= -1, maxit = 30000, reltol=sqrt(.Machine$double.eps)), hessian= T)
  
#   temp.mle <- ucminf(par0, hw1.loglike, y=y, x1=x1, x2=x2)
  
   if(temp.mle$convergence!=0)
     stop("!!!DID NOT CONVERGE!!!")
  
  return(temp.mle)
}

### get starting values for MLE; standard OLS estimation ###

for(i in 1:reps){
  
#e <- rnorm(n=n, mean=0, sd=5) # n-random normal draws for error term
#x1 <- rnorm(n=n, mean=100, sd=7) # n-random normal draws for x1 data
#x2 <- rnorm(n=n, mean=1000, sd=10) # n-random normal draws for x2 data

e= sqrt(exp(-2+ 0.25* x1)) *rnorm(n)

y <- 10+ 1* x1+ 1* x2 +e # construct model

X <- matrix(c(rep(1, n), x1, x2), nrow=n, ncol=k) # gather X-data into single matrix

b_ols <- solve(crossprod(X, X)) %*% crossprod(X, y) # faster to use matrix algebra over lm function

##################################################################
### MLE estimation ###

par0= c(b_ols[1], b_ols[2], b_ols[3], 0, 0) # obtain starting values from ols

#hw1.loglike(params=par0, y=y, x1=x1, x2=x2)

beta_mle <- hw1.mle(par0=par0, y=y, x1=x1, x2=x2) # run MLE precedure
#beta_mle1 <- nlm(hw1.loglike, p=par0, y=y, x1=x1, x2=x2) # run MLE precedure

beta_mle_params <- matrix(beta_mle$par, nrow=5)
dimnames(beta_mle_params) <- list(c(), c("betas_mle"))
beta_mle_params

var_mle <- (-1)* diag(solve(beta_mle$hessian))

#mle_se <- sqrt(var_mle)

#mle_t_val <- beta_mle$par / mle_se
#mle_t_val <- matrix(mle_t_val, nrow=5)
#dimnames(mle_t_val) <- list(c(), c("t_values__mle"))
#mle_t_val
i <- i+1
}
```
  
\newpage  
  
# MLE

\begin{equation}
\ln L =  - 0.5n\log (2\pi ) - 0.5\sum\limits_{}^{} {({\sigma ^2}) - 0.5\sum\limits_{}^{} {\left[ {\frac{{{{(y - X'\beta )}^2}}}{{{\sigma ^2}}}} \right]} }
\end{equation}
  
where,  

${\sigma ^2} \simeq \exp ({\alpha _0} + {\alpha _1}{x_1})$





